Fenwick-Tree

---
Introdução

Uma árvore de Fenwick ou árvore binária indexada, do inglês binary indexed tree, é uma estrutura de dados com o objetivo de atualizar elementos em listas e calcular somas cumulativas de maneira eficiente. Esta estrutura foi proposta por Peter Fenwick em 1994 (A New Data Structure for Cumulative Frequency Tables).

Quando comparado com listas numéricas simples, como vetores, a árvore de Fenwick pode atualizar elementos e calcular somas cumulativas de maneira muito mais eficiente. Em um vetor de N elementos, podemos atualizar um elemento ou calcular o somatório com uma complexidade de tempo O(N). Em uma árvore de Fenwick, as mesmas operações apresentam uma complexidade de tempo O(log N).

---
Prefix Sum

A soma de uma sequência de números em ordem prefixa, também conhecida como soma de varredura ou cumulativa, é a simples soma dos N primeiros números da sequência, como:

entrada			1		2		3		4		5		6 	...
somatório 		1		3		6		10		15		21 	...

Ou seja, Y(i) = Y(y-1) + X(i)
Por mais trivial que pareça, a aplicação de somas cumulativas é vasta. Pode ser usada em algoritmos de ordenação, por exemplo.

---
Definição

Supondo uma aplicação com interesse na soma cumulativa de uma lista de números, por exemplo:

posição			1		2		3		4		5		6		7
lista 			5		1		8		11		52		28		0
soma 			5		6		14		25		77		105		105

Agora, no caso de uma atualização de um elemento, para a lista, a alteração é simples e tem complexidade O(1), porém, para a soma, a alteração tem complexidade O(N). Por exemplo, ao alterar o terceiro elemento, é necessário alterar todos os posteriores:

posição			1		2		3		4		5		6		7
lista 			5		1		8+7		11		52		28		0
soma 			5		6		14+7	25+7	77+7	105+7	105+7

lista 			5		1		15		11		52		28		0
soma 			5		6		21		32		84		112		112

Para se resolver esse problema de complexidade de tempo, se propõem o uso de uma árvore binária, onde cada nó armazena a soma cumulativa de todos os nós a sua esquerda, incluindo ele mesmo.

posição			1		2		3		4		5		6		7
lista 			5		1		15		11		52		28		0
soma 			5		6		21		32		84		112		112

4
2                  6
1        3         5         7

4 (32)
2 (6)              6 (80)
1 (5)    3 (15)    5 (52)    7 (0)

Com esse estrutura é fácil determinar a soma cumulativa de um ponto. O conceito é usar um contador iniciando em zero, então fazer uma busca binária normal até encontrar o nó que deseja, porém com uma regra: ao mover para a direita, o contador é incrementado com o valor do nó.

Por exemplo, para a soma cumulativa da posição/nó (3):

4 (32)
2 (6)              6 (80)
1 (5)    3 (15)    5 (52)    7 (0)

Iniciando na raiz (4). Contador é igual a zero.
(3) é menor que (4), então para a esquerda. Contador é mantido em zero.
(3) é maior que (2), então para a direita. Nesse caso o contador é incrementado em 6.
Encontrou o nó (3). O contador é incrementado em 15.
A soma cumulativa do elemento (3) é 0+6+15 = 21.

Outro exemplo, para a soma cumulativa da posição/nó (5):

4 (32)
2 (6)              6 (80)
1 (5)    3 (15)    5 (52)    7 (0)

Iniciando na raiz (4). Contador é igual a zero.
(5) é maior que (4), então para a direita. Contador é incrementado em 32.
(5) é menor que (6), então para a esquerda. Contador é mantido.
Encontrou o nó (5). O contador é incrementado em 52.
A soma cumulativa do elemento (5) é 0+32+52 = 84.

Iniciando no nó folha, de modo reverso, o contador deve ser iniciado com o valor do nó e caminhar em direção a raiz. Quando o nó for o da direita, o contador é incrementado.

Por exemplo, iniciando em (3):

4 (32)
2 (6)              6 (80)
1 (5)    3 (15)    5 (52)    7 (0)

Iniciando em (3). Contador é igual a 15.
(3) é maior que (2), filho da direita. Contador é incrementado em 6.
(3) é menor que (4), filho da esquerda. Contador se mantém.
A soma cumulativa do elemento (3) é 15+6+0 = 21.

Agora, para incrementar ou atualizar o valor de um nó, é necessário atualizar os nós da árvore que incluírem a sub-árvore da esquerda. Para fazer isso deve-se incrementar a soma do nó desejado e então caminhar em direção a raiz da árvore. Sempre que for um filho esquerdo, deve-se incrementar a soma daquele nó.

Por exemplo, para incrementar a soma do nó (1) em 5:

4 (32)
2 (6)              6 (80)
1 (5)    3 (15)    5 (52)    7 (0)

Iniciando em (1). Incrementar em 5:

4 (32)
2 (6)              6 (80)
1 (5+5)  3 (15)    5 (52)    7 (0)

Caminha em direção a raiz, se for um filho da esquerda, incrementa também o pai:

4 (32)
2 (6)              6 (80)
1 (5+5)  3 (15)    5 (52)    7 (0)

Novamente, se for um filho da esquerda, incrementa:

4 (32+5)
2 (6)              6 (80)
1 (5+5)  3 (15)    5 (52)    7 (0)

A nova árvore, portanto:

4 (37)
2 (11)             6 (80)
1 (10)  3 (15)     5 (52)    7 (0)

Então, se verifica que a soma e atualização de elementos na árvore binária é simples e a recursividade é de grande valia. Porém, ainda há a questão de como se gerar a árvore binária a partir de uma lista numérica de entrada. Para isso é necessário relembrar a representação binária (zeros e uns):

1: 001
2: 010
3: 011
4: 100
...

100 (37)
010 (11)                110 (80)
001 (10)    011 (15)    101 (52)    111 (0)

Aqui, se faz uma observação, se rotacionarmos os índices para a esquerda até o primeiro 1 menos significativo, temos:

1: 001 >> 00
2: 010 >> 0
3: 011 >> 01
4: 100 >> vazio
5: 101 >> 10
6: 110 >> 1
7: 111 >> 11
...

vazio (37)
0     (11)                  1     (80)
00    (10)    01    (15)    10    (52)    11    (0)

O que se verifica: se o caminho é o da esquerda, adiciona um 0 e se for o da direita, adiciona um 1. Isso é importante porque as operações de pesquisa e atualização dependem do caminho de acesso: filho da esquerda ou da direita. Ou seja, dado o nó N, o próximo nó no caminho de acesso de volta à raiz é dado pela representação binária de N removendo o 1 menos significativo.

Isso significa que é possível calcular a soma cumulativa dos nós com o seguinte algoritmo:

Escrever o índice do nó N em binário
Setar o contador para 0
Repetir o seguinte enquanto N for diferente de 0
	Adiciona o valor ao nó N
	Limpa o bit menos significativo do índice N

Para o algoritmo de atualização, é possível inverter a lógica, trocando 1 por 0 e 0 por 1. Por causa desse truque de índices binários, não é preciso armazenar uma árvore explicitamente. Pode-se armazenar um vetor e utilizar as técnicas de bit a bit para navegar no vetor.

---
Descrição do Tipo Abstrato de Dados

---
Aplicações

Como a atualização dos elementos pode ser feita dinamicamente, e como a complexidade é logarítmica, a árvore de Fenwick pode ser utilizada em diversas aplicações.

A soma cumulativa é útil em operações de convolução (basicamente uma soma de multiplicações) e, para matrizes de grandes dimensões, uma baixa complexidade de tempo é importante. 

Como dito, outra aplicação é em algoritmos de ordenação. O algoritmo 'counting sort', por exemplo, usa a soma cumulativa para calcular a posição de cada elemento de entrada em um vetor de saída. Esse algoritmo é usado como parte do 'radix sort'.

void counting_sort (int input[], int num, int max) {
	int count[num] = {0};
	
	// counting the occurrence of each element in the array input[]
	for (int i = 0; i < num; ++i)
		count[input[i]] += 1;
	
	// the value at each index in count[] is the occurrence of that element
	for (int i = 0; i <= max; ++i)
		for(int j = 1; j <= count[i]; ++j)
			printf("%d ", i);
}

Exemplo:
	input[15] = {0, 4, 2, 2, 3, 0, 0, 1, 1, 0, 1, 0, 2, 4, 2};
	counting_sort (input, 15, 4);
	count[4] = {5, 3, 4, 1, 2};
	output: 0 0 0 0 0 1 1 1 2 2 2 2 3 4 4


Outras aplicações?
(...)

---
Implementação como Lista

---
Implementação como Árvore

---
Complexidade

O(N.log N) para construção da árvore.
O(log N) para ambas operações, de atualização e de soma.
